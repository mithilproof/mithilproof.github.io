var {
  _optionalChain
} = require('@sentry/utils/cjs/buildPolyfills');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const flush = require('./flush.js');

/**
 * Wraps a function on the edge runtime with error and performance monitoring.
 */
function withEdgeWrapping(
  handler,
  options,
) {
  return async function ( ...args) {
    const req = args[0];
    const currentScope = core.getCurrentHub().getScope();
    const prevSpan = _optionalChain([currentScope, 'optionalAccess', _ => _.getSpan, 'call', _2 => _2()]);

    let span;

    if (core.hasTracingEnabled()) {
      if (prevSpan) {
        span = prevSpan.startChild({
          description: options.spanDescription,
          op: options.spanOp,
        });
      } else if (req instanceof Request) {
        // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)
        let traceparentData;

        const sentryTraceHeader = req.headers.get('sentry-trace');
        if (sentryTraceHeader) {
          traceparentData = utils.extractTraceparentData(sentryTraceHeader);
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log(`[Tracing] Continuing trace ${_optionalChain([traceparentData, 'optionalAccess', _3 => _3.traceId])}.`);
        }

        const dynamicSamplingContext = utils.baggageHeaderToDynamicSamplingContext(req.headers.get('baggage'));

        span = core.startTransaction({
          name: options.spanDescription,
          op: options.spanOp,
          ...traceparentData,
          metadata: {
            dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
            source: 'route',
          },
        });
      }

      _optionalChain([currentScope, 'optionalAccess', _4 => _4.setSpan, 'call', _5 => _5(span)]);
    }

    try {
      const handlerResult = await handler.apply(this, args);

      if ((handlerResult ) instanceof Response) {
        _optionalChain([span, 'optionalAccess', _6 => _6.setHttpStatus, 'call', _7 => _7(handlerResult.status)]);
      } else {
        _optionalChain([span, 'optionalAccess', _8 => _8.setStatus, 'call', _9 => _9('ok')]);
      }

      return handlerResult;
    } catch (e) {
      // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can
      // store a seen flag on it.
      const objectifiedErr = utils.objectify(e);

      _optionalChain([span, 'optionalAccess', _10 => _10.setStatus, 'call', _11 => _11('internal_error')]);

      core.captureException(objectifiedErr, scope => {
        scope.setSpan(span);
        scope.addEventProcessor(event => {
          utils.addExceptionMechanism(event, {
            type: 'instrument',
            handled: false,
            data: {
              function: options.mechanismFunctionName,
            },
          });
          return event;
        });

        return scope;
      });

      throw objectifiedErr;
    } finally {
      _optionalChain([span, 'optionalAccess', _12 => _12.finish, 'call', _13 => _13()]);
      _optionalChain([currentScope, 'optionalAccess', _14 => _14.setSpan, 'call', _15 => _15(prevSpan)]);
      await flush.flush(2000);
    }
  };
}

exports.withEdgeWrapping = withEdgeWrapping;
//# sourceMappingURL=edgeWrapperUtils.js.map
