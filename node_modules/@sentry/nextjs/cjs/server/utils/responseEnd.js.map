{"version":3,"file":"responseEnd.js","sources":["../../../../src/server/utils/responseEnd.ts"],"sourcesContent":["import { flush } from '@sentry/node';\nimport type { Transaction } from '@sentry/types';\nimport { fill, logger } from '@sentry/utils';\nimport type { ServerResponse } from 'http';\n\nimport type { ResponseEndMethod, WrappedResponseEndMethod } from '../types';\n\n/**\n * Wrap `res.end()` so that it closes the transaction and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param transaction The transaction tracing request handling\n * @param res: The request's corresponding response\n */\nexport function autoEndTransactionOnResponseEnd(transaction: Transaction, res: ServerResponse): void {\n  const wrapEndMethod = (origEnd: ResponseEndMethod): WrappedResponseEndMethod => {\n    return function sentryWrappedEnd(this: ServerResponse, ...args: unknown[]) {\n      void finishTransaction(transaction, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end as WrappedResponseEndMethod).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's transaction and set HTTP status data */\nexport async function finishTransaction(transaction: Transaction | undefined, res: ServerResponse): Promise<void> {\n  if (transaction) {\n    transaction.setHttpStatus(res.statusCode);\n\n    // If any open spans are set to finish when the response ends, it sets up a race condition between their `finish`\n    // calls and the transaction's `finish` call - and any spans which lose the race will get dropped from the\n    // transaction. To prevent this, push `transaction.finish` to the next event loop so that it's guaranteed to lose\n    // the race, and wait for it to be done before flushing events.\n    const transactionFinished: Promise<void> = new Promise(resolve => {\n      setImmediate(() => {\n        transaction.finish();\n        resolve();\n      });\n    });\n    await transactionFinished;\n  }\n}\n\n/** Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda ends */\nexport async function flushQueue(): Promise<void> {\n  try {\n    __DEBUG_BUILD__ && logger.log('Flushing events...');\n    await flush(2000);\n    __DEBUG_BUILD__ && logger.log('Done flushing events');\n  } catch (e) {\n    __DEBUG_BUILD__ && logger.log('Error while flushing events:\\n', e);\n  }\n}\n"],"names":["fill","logger","flush"],"mappings":";;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAA,+BAAA,CAAA,WAAA,EAAA,GAAA,EAAA;AACA,EAAA,MAAA,aAAA,GAAA,CAAA,OAAA,KAAA;AACA,IAAA,OAAA,SAAA,gBAAA,EAAA,GAAA,IAAA,EAAA;AACA,MAAA,KAAA,iBAAA,CAAA,WAAA,EAAA,IAAA,CAAA,CAAA;AACA,MAAA,OAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,GAAA,IAAA,CAAA,CAAA;AACA,KAAA,CAAA;AACA,GAAA,CAAA;AACA;AACA;AACA;AACA,EAAA,IAAA,GAAA,CAAA,GAAA,IAAA,CAAA,CAAA,GAAA,CAAA,GAAA,GAAA,mBAAA,EAAA;AACA,IAAAA,UAAA,CAAA,GAAA,EAAA,KAAA,EAAA,aAAA,CAAA,CAAA;AACA,GAAA;AACA,CAAA;AACA;AACA;AACA,eAAA,iBAAA,CAAA,WAAA,EAAA,GAAA,EAAA;AACA,EAAA,IAAA,WAAA,EAAA;AACA,IAAA,WAAA,CAAA,aAAA,CAAA,GAAA,CAAA,UAAA,CAAA,CAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,MAAA,mBAAA,GAAA,IAAA,OAAA,CAAA,OAAA,IAAA;AACA,MAAA,YAAA,CAAA,MAAA;AACA,QAAA,WAAA,CAAA,MAAA,EAAA,CAAA;AACA,QAAA,OAAA,EAAA,CAAA;AACA,OAAA,CAAA,CAAA;AACA,KAAA,CAAA,CAAA;AACA,IAAA,MAAA,mBAAA,CAAA;AACA,GAAA;AACA,CAAA;AACA;AACA;AACA,eAAA,UAAA,GAAA;AACA,EAAA,IAAA;AACA,IAAA,iEAAAC,YAAA,CAAA,GAAA,CAAA,oBAAA,CAAA,CAAA;AACA,IAAA,MAAAC,UAAA,CAAA,IAAA,CAAA,CAAA;AACA,IAAA,iEAAAD,YAAA,CAAA,GAAA,CAAA,sBAAA,CAAA,CAAA;AACA,GAAA,CAAA,OAAA,CAAA,EAAA;AACA,IAAA,CAAA,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,KAAAA,YAAA,CAAA,GAAA,CAAA,gCAAA,EAAA,CAAA,CAAA,CAAA;AACA,GAAA;AACA;;;;;;"}