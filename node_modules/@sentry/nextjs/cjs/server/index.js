var {
  _optionalChain
} = require('@sentry/utils/cjs/buildPolyfills');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const integrations = require('@sentry/integrations');
const node = require('@sentry/node');
const utils = require('@sentry/utils');
const path = require('path');
const devErrorSymbolicationEventProcessor = require('../common/devErrorSymbolicationEventProcessor.js');
const getVercelEnv = require('../common/getVercelEnv.js');
const metadata = require('../common/metadata.js');
const isBuild = require('./utils/isBuild.js');
const _error = require('../common/_error.js');
const wrapApiHandlerWithSentryVercelCrons = require('../common/wrapApiHandlerWithSentryVercelCrons.js');
const wrapGetStaticPropsWithSentry = require('./wrapGetStaticPropsWithSentry.js');
const wrapGetInitialPropsWithSentry = require('./wrapGetInitialPropsWithSentry.js');
const wrapAppGetInitialPropsWithSentry = require('./wrapAppGetInitialPropsWithSentry.js');
const wrapDocumentGetInitialPropsWithSentry = require('./wrapDocumentGetInitialPropsWithSentry.js');
const wrapErrorGetInitialPropsWithSentry = require('./wrapErrorGetInitialPropsWithSentry.js');
const wrapGetServerSidePropsWithSentry = require('./wrapGetServerSidePropsWithSentry.js');
const wrapApiHandlerWithSentry = require('./wrapApiHandlerWithSentry.js');
const wrapServerComponentWithSentry = require('./wrapServerComponentWithSentry.js');

/**
 * A passthrough error boundary for the server that doesn't depend on any react. Error boundaries don't catch SSR errors
 * so they should simply be a passthrough.
 */
const ErrorBoundary = (props) => {
  if (!props.children) {
    return null;
  }

  if (typeof props.children === 'function') {
    return (props.children )();
  }

  // since Next.js >= 10 requires React ^16.6.0 we are allowed to return children like this here
  return props.children ;
};

/**
 * A passthrough error boundary wrapper for the server that doesn't depend on any react. Error boundaries don't catch
 * SSR errors so they should simply be a passthrough.
 */
function withErrorBoundary(
  WrappedComponent,
) {
  return WrappedComponent ;
}

/**
 * Just a passthrough since we're on the server and showing the report dialog on the server doesn't make any sense.
 */
function showReportDialog() {
  return;
}

const globalWithInjectedValues = global

;

// TODO (v8): Remove this
/**
 * @deprecated This constant will be removed in the next major update.
 */
const IS_BUILD = isBuild.isBuild();

const IS_VERCEL = !!process.env.VERCEL;

/** Inits the Sentry NextJS SDK on node. */
function init(options) {
  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && options.debug) {
    utils.logger.enable();
  }

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('Initializing SDK...');

  if (sdkAlreadyInitialized()) {
    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('SDK already initialized');
    return;
  }

  metadata.buildMetadata(options, ['nextjs', 'node']);

  options.environment =
    options.environment || process.env.SENTRY_ENVIRONMENT || getVercelEnv.getVercelEnv(false) || process.env.NODE_ENV;

  addServerIntegrations(options);
  // Right now we only capture frontend sessions for Next.js
  options.autoSessionTracking = false;

  node.init(options);

  const filterTransactions = event => {
    return event.type === 'transaction' && event.transaction === '/404' ? null : event;
  };

  filterTransactions.id = 'NextServer404TransactionFilter';

  node.configureScope(scope => {
    scope.setTag('runtime', 'node');
    if (IS_VERCEL) {
      scope.setTag('vercel', true);
    }

    scope.addEventProcessor(filterTransactions);

    if (process.env.NODE_ENV === 'development') {
      scope.addEventProcessor(devErrorSymbolicationEventProcessor.devErrorSymbolicationEventProcessor);
    }
  });

  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.log('SDK successfully initialized');
}

function sdkAlreadyInitialized() {
  const hub = node.getCurrentHub();
  return !!hub.getClient();
}

function addServerIntegrations(options) {
  let integrations$1 = options.integrations || [];

  // This value is injected at build time, based on the output directory specified in the build config. Though a default
  // is set there, we set it here as well, just in case something has gone wrong with the injection.
  const distDirName = globalWithInjectedValues.__rewriteFramesDistDir__ || '.next';
  // nextjs always puts the build directory at the project root level, which is also where you run `next start` from, so
  // we can read in the project directory from the currently running process
  const distDirAbsPath = path.resolve(process.cwd(), distDirName);
  const SOURCEMAP_FILENAME_REGEX = new RegExp(utils.escapeStringForRegex(distDirAbsPath));

  const defaultRewriteFramesIntegration = new integrations.RewriteFrames({
    iteratee: frame => {
      frame.filename = _optionalChain([frame, 'access', _ => _.filename, 'optionalAccess', _2 => _2.replace, 'call', _3 => _3(SOURCEMAP_FILENAME_REGEX, 'app:///_next')]);
      return frame;
    },
  });
  integrations$1 = utils.addOrUpdateIntegration(defaultRewriteFramesIntegration, integrations$1);

  const defaultOnUncaughtExceptionIntegration = new node.Integrations.OnUncaughtException({
    exitEvenIfOtherHandlersAreRegistered: false,
  });
  defaultOnUncaughtExceptionIntegration.allowExclusionByUser = true;
  integrations$1 = utils.addOrUpdateIntegration(defaultOnUncaughtExceptionIntegration, integrations$1, {
    _options: { exitEvenIfOtherHandlersAreRegistered: false },
  });

  if (core.hasTracingEnabled(options)) {
    const defaultHttpTracingIntegration = new node.Integrations.Http({ tracing: true });
    integrations$1 = utils.addOrUpdateIntegration(defaultHttpTracingIntegration, integrations$1, {
      _tracing: {},
    });
  }

  options.integrations = integrations$1;
}

// TODO (v8): Remove this
/**
 * @deprecated This constant will be removed in the next major update.
 */
const deprecatedIsBuild = () => isBuild.isBuild();

exports.captureUnderscoreErrorException = _error.captureUnderscoreErrorException;
exports.wrapApiHandlerWithSentryVercelCrons = wrapApiHandlerWithSentryVercelCrons.wrapApiHandlerWithSentryVercelCrons;
exports.withSentryGetStaticProps = wrapGetStaticPropsWithSentry.withSentryGetStaticProps;
exports.wrapGetStaticPropsWithSentry = wrapGetStaticPropsWithSentry.wrapGetStaticPropsWithSentry;
exports.withSentryServerSideGetInitialProps = wrapGetInitialPropsWithSentry.withSentryServerSideGetInitialProps;
exports.wrapGetInitialPropsWithSentry = wrapGetInitialPropsWithSentry.wrapGetInitialPropsWithSentry;
exports.withSentryServerSideAppGetInitialProps = wrapAppGetInitialPropsWithSentry.withSentryServerSideAppGetInitialProps;
exports.wrapAppGetInitialPropsWithSentry = wrapAppGetInitialPropsWithSentry.wrapAppGetInitialPropsWithSentry;
exports.withSentryServerSideDocumentGetInitialProps = wrapDocumentGetInitialPropsWithSentry.withSentryServerSideDocumentGetInitialProps;
exports.wrapDocumentGetInitialPropsWithSentry = wrapDocumentGetInitialPropsWithSentry.wrapDocumentGetInitialPropsWithSentry;
exports.withSentryServerSideErrorGetInitialProps = wrapErrorGetInitialPropsWithSentry.withSentryServerSideErrorGetInitialProps;
exports.wrapErrorGetInitialPropsWithSentry = wrapErrorGetInitialPropsWithSentry.wrapErrorGetInitialPropsWithSentry;
exports.withSentryGetServerSideProps = wrapGetServerSidePropsWithSentry.withSentryGetServerSideProps;
exports.wrapGetServerSidePropsWithSentry = wrapGetServerSidePropsWithSentry.wrapGetServerSidePropsWithSentry;
exports.withSentry = wrapApiHandlerWithSentry.withSentry;
exports.withSentryAPI = wrapApiHandlerWithSentry.withSentryAPI;
exports.wrapApiHandlerWithSentry = wrapApiHandlerWithSentry.wrapApiHandlerWithSentry;
exports.wrapServerComponentWithSentry = wrapServerComponentWithSentry.wrapServerComponentWithSentry;
exports.ErrorBoundary = ErrorBoundary;
exports.IS_BUILD = IS_BUILD;
exports.init = init;
exports.isBuild = deprecatedIsBuild;
exports.showReportDialog = showReportDialog;
exports.withErrorBoundary = withErrorBoundary;
for (const k in node) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = node[k];
}
//# sourceMappingURL=index.js.map
