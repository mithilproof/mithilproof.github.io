import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';
import { getCurrentHub, hasTracingEnabled, startTransaction, captureException } from '@sentry/core';
import { extractTraceparentData, logger, baggageHeaderToDynamicSamplingContext, objectify, addExceptionMechanism } from '@sentry/utils';
import { flush } from './flush.js';

/**
 * Wraps a function on the edge runtime with error and performance monitoring.
 */
function withEdgeWrapping(
  handler,
  options,
) {
  return async function ( ...args) {
    const req = args[0];
    const currentScope = getCurrentHub().getScope();
    const prevSpan = _optionalChain([currentScope, 'optionalAccess', _ => _.getSpan, 'call', _2 => _2()]);

    let span;

    if (hasTracingEnabled()) {
      if (prevSpan) {
        span = prevSpan.startChild({
          description: options.spanDescription,
          op: options.spanOp,
        });
      } else if (req instanceof Request) {
        // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)
        let traceparentData;

        const sentryTraceHeader = req.headers.get('sentry-trace');
        if (sentryTraceHeader) {
          traceparentData = extractTraceparentData(sentryTraceHeader);
          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Continuing trace ${_optionalChain([traceparentData, 'optionalAccess', _3 => _3.traceId])}.`);
        }

        const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(req.headers.get('baggage'));

        span = startTransaction({
          name: options.spanDescription,
          op: options.spanOp,
          ...traceparentData,
          metadata: {
            dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
            source: 'route',
          },
        });
      }

      _optionalChain([currentScope, 'optionalAccess', _4 => _4.setSpan, 'call', _5 => _5(span)]);
    }

    try {
      const handlerResult = await handler.apply(this, args);

      if ((handlerResult ) instanceof Response) {
        _optionalChain([span, 'optionalAccess', _6 => _6.setHttpStatus, 'call', _7 => _7(handlerResult.status)]);
      } else {
        _optionalChain([span, 'optionalAccess', _8 => _8.setStatus, 'call', _9 => _9('ok')]);
      }

      return handlerResult;
    } catch (e) {
      // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can
      // store a seen flag on it.
      const objectifiedErr = objectify(e);

      _optionalChain([span, 'optionalAccess', _10 => _10.setStatus, 'call', _11 => _11('internal_error')]);

      captureException(objectifiedErr, scope => {
        scope.setSpan(span);
        scope.addEventProcessor(event => {
          addExceptionMechanism(event, {
            type: 'instrument',
            handled: false,
            data: {
              function: options.mechanismFunctionName,
            },
          });
          return event;
        });

        return scope;
      });

      throw objectifiedErr;
    } finally {
      _optionalChain([span, 'optionalAccess', _12 => _12.finish, 'call', _13 => _13()]);
      _optionalChain([currentScope, 'optionalAccess', _14 => _14.setSpan, 'call', _15 => _15(prevSpan)]);
      await flush(2000);
    }
  };
}

export { withEdgeWrapping };
//# sourceMappingURL=edgeWrapperUtils.js.map
